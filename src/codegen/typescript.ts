/**
 * COBridge -- TypeScript Type Generator
 *
 * Generates TypeScript interface declarations from a parsed COBOL copybook AST.
 * Maps COBOL data types to TypeScript types and produces well-formatted,
 * documented type definitions.
 */

import { Copybook, CopybookField, UsageType } from "../parser/types.js";
import { cobolNameToCamelCase, cobolNameToPascalCase } from "./openapi.js";

/**
 * Map a CopybookField to a TypeScript type string.
 */
function fieldToTsType(field: CopybookField): string {
  if (field.isGroup) {
    return cobolNameToPascalCase(field.name);
  }

  if (!field.picture) {
    // No PIC — COMP-1/COMP-2 without PIC are still numbers
    if (field.usage === UsageType.COMP_1 || field.usage === UsageType.COMP_2) {
      return "number";
    }
    return "string";
  }

  const pic = field.picture;

  // Alphanumeric / alphabetic -> string
  if (pic.type === "alphanumeric" || pic.type === "alpha") {
    return "string";
  }

  // Numeric — computational usages map to number
  switch (field.usage) {
    case UsageType.COMP:
    case UsageType.COMP_1:
    case UsageType.COMP_2:
    case UsageType.COMP_3:
    case UsageType.BINARY:
    case UsageType.PACKED_DECIMAL:
      return "number";
    case UsageType.DISPLAY:
    default:
      // DISPLAY numeric could be either — use number for simplicity
      return "number";
  }
}

/**
 * Generate an interface declaration for a group field and collect
 * any nested interface declarations needed.
 */
function generateInterface(
  field: CopybookField,
  output: string[],
  indent: string = ""
): void {
  const interfaceName = cobolNameToPascalCase(field.name);

  // First, recursively generate interfaces for any group children
  for (const child of field.children) {
    if (child.isGroup) {
      generateInterface(child, output, indent);
    }
  }

  // Generate this interface
  output.push(`${indent}/** COBOL group: ${field.name} (level ${field.levelNumber}, ${field.byteLength} bytes) */`);
  output.push(`${indent}export interface ${interfaceName} {`);

  for (const child of field.children) {
    if (child.levelNumber === 88) continue;

    const propName = cobolNameToCamelCase(child.name);
    let tsType = fieldToTsType(child);

    // Add JSDoc comment with COBOL info
    if (child.picture) {
      output.push(`${indent}  /** PIC ${child.picture.raw} ${child.usage} (offset ${child.startOffset}, ${child.byteLength} bytes) */`);
    } else if (child.isGroup) {
      output.push(`${indent}  /** Group item: ${child.name} (${child.byteLength} bytes) */`);
    }

    // Wrap in array if OCCURS
    if (child.occurs) {
      tsType = `${tsType}[]`;
    }

    output.push(`${indent}  ${propName}: ${tsType};`);
  }

  output.push(`${indent}}`);
  output.push("");
}

/**
 * Generate TypeScript interface declarations from a parsed Copybook.
 *
 * @param copybook - The parsed copybook AST
 * @returns A string containing TypeScript interface declarations
 */
export function generateTypeScriptTypes(copybook: Copybook): string {
  const output: string[] = [];

  output.push(`/**`);
  output.push(` * Auto-generated TypeScript types for COBOL copybook: ${copybook.name}`);
  output.push(` * Total record length: ${copybook.totalLength} bytes`);
  output.push(` *`);
  output.push(` * Generated by COBridge`);
  output.push(` */`);
  output.push("");

  for (const field of copybook.fields) {
    if (field.isGroup) {
      generateInterface(field, output);
    } else {
      // Top-level elementary field — export as a type alias
      const typeName = cobolNameToPascalCase(field.name);
      const tsType = fieldToTsType(field);
      if (field.picture) {
        output.push(`/** PIC ${field.picture.raw} ${field.usage} (${field.byteLength} bytes) */`);
      }
      output.push(`export type ${typeName} = ${tsType};`);
      output.push("");
    }
  }

  return output.join("\n");
}
